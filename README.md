# Khayyal Backend

## Notes on handling images

There is a set of `util` function to help in handling image uploads.

All of these are located in [utils/image_management.py](utils/image_management.py)

Specifically,

- [`save_image`](#save_image): given a `UploadFile` object it saves the image asynchronously
in the filesystem and creates a record in the database. It 
returns an `image_id` to access the image later.


- `generate_image_url()`: given the `image_id` that was generated by the `save_image` function,
it returns an `image_url` that can be returned directly to the user to access the image 
associated with the `image_id`.


- `delete_image()`: given the `image_id` that was generated by the `save_image` function 
it deletes the file from the file system was well was removes the record from
the database.

### Usage



A few demo routes are implemented in the [api/image_management/image_management_api.py](api/image_management/image_management_api.py)
to help you understand its usage.

**Caution**: before trying these demo apis in your local machine create a 
directory called `user-upload-images` in the root directory of the project.

#### `save_image()`

```python
@upload_images_demo_router.post("/upload-image-demo")
async def upload_image_demo(image: UploadFile):
    # the save_image() util function is an async function, it should always be called
    # from an async function with the await keyword
    image_id = await save_image(image_file=image)

    # saving the image id in the database for later usages
    # caution: this is for demonstration purposes, database code should always be in data package
    upload_images_demo_collection.insert_one({"image_id": image_id})

    return {"status": "OK"}
```

This route receives an image file from the user through the `UploadFile` class 
provided by `Fastapi`.

The `save_image` function is an asynchronous function. So, it must be called
from a `async` function with the `await` keyword. Pass the image file directly
to it. And it'll handle the upload and return an `image_id`. 

Store the `image_id` in the respective collections to retrieve it later. For example,
if the image is of a `horse` it might be stored in the `horses` collection in the
`document` of the respective `horse`. 

**Summary**:
- While using `save_image()` pass an instance of `UploadFile` received in the request.
- `save_image()` is an asynchronous function. Therefore, it must be called from
a `async` function with the `await` keyword.
- Store the returned `image_id` in a collection to retrieve the image later.

#### `generate_image_url()`

```python
@upload_images_demo_router.get("/get-all-image-urls")
async def get_all_image_url(request: Request):
    uploaded_images = upload_images_demo_collection.find()

    uploaded_image_ids = [image["image_id"] for image in uploaded_images]

    generated_url_list = [generate_image_url(image_id=image_id, request=request)
                          for image_id in uploaded_image_ids]

    return {"image_url_list": generated_url_list}
```

Pass the `image_id` generated by the `save_image` function to `generate_image_url`.
It would generate an url that can be returned to the user. With the url the user will
be able to access the image.

**Summary**:
- Pass the `image_id` generated by the `save_image` function to `generate_image_url`.
- Along with the `image_id` you have to pass the `Request` object as well.
- The `Request` object helps the function to derive the current `base_url`.
- The `generated_url` can be returned to the user directly.

#### `delete_image()`

```python
@upload_images_demo_router.delete("/delete-all-uploaded-images-demo")
async def delete_all_uploaded_images_demo():
    uploaded_images = upload_images_demo_collection.find()

    uploaded_image_ids = [image["image_id"] for image in uploaded_images]

    result = False

    # deleting from the database collection
    for image_id in uploaded_image_ids:
        upload_images_demo_collection.delete_one({"image_id": image_id})

    # deleting from the file_system with the help of the delete_image util function
    for image_id in uploaded_image_ids:
        # delete_image util function is an async function, and it should always be awaited
        result = await delete_image(image_id=image_id)

    return {"status": result}
```
The `delete_image` function deletes the image file from the file system and
removes the record from the database. This operation is irreversible.

**Summary**:
- Pass the `image_id` to `delete_image` to delete the image permanently.
- This operation is irreversible.
- Ensure to remove the database record of the `image_id` you have created 
while saving the image.
- The `delete_image` function is an asynchronous function. You can only call
it from an `async` function with the `await` keyword.

This is the standard procedure for handling images across the database. We do not
have access restriction on the images as of now. If restricting access to the images
become a requirement necessary changes in the functions would be made to accommodate the
functionalities.

## Notes on Deployment
For cloud-related services, we rely on `GCP (Google Cloud Platform)`.
The application gets deployed in an instance of `GCE(Google Compute Engine)`. Right now
only the `dev` server is live. The `swagger docs` are accessible on `http://34.45.27.123:8000/docs/`.
Access the [dev server](http://34.45.27.123:8000/docs/).
### Dev
With each push to the `main` branch, the application gets automatically deployed
to the `server` using `Github Actions CI/CD Workflow`. The workflow script is located in 
the `.github/workflows` directory with the filename
[deploy-to-khayyal-dev.yml](.github/workflows/deploy-to-khayyal-dev.yml). 

To understand the steps the workflow executes in the completion of the 
deployment please see https://github.com/Platforms-KSA/Khayyal_Django_Backend_Enhancements/issues/26.

When each of your PRs gets merged into main, the workflow automatically executes. 
After the execution of the workflow (typically a few minutes after the merge) please
check whether the deployment has been successful by trying to access the docs from
the web. 

If it is accessible then all is okay. You can verify whether the new
functionalities implemented by you are working expectedly from the docs.

In case it is not accessible and the browser is throwing some kind of error then
the deployment has not been successful. 

To mitigate the issue, `ssh` into the dev server and try to run the `khayyal-backend`
docker image without the `-d` flag to not start it in a detached mode. 

Run the following commands:

```bash
sudo docker stop khayyal-backend # to stop the container if already running
sudo docker rm khayyal-backend # remove the container
```

After running the commands try to start the docker container
using the following command:

```bash
sudo docker run -p 8000:80 --name khayyal-backend --mount type=bind,source=/home/khayyal-backend/secrets.json,target=/app/secrets.json --mount type=bind,source=/home/khayyal-backend/logs,target=/app/logs khayyal-backend
```

The absence of the `-d` flag from the `docker run` command will run the container
in the current terminal session. You would be able to see what is going wrong in the
start-up process of the application. 

A very common issue that results in deployment failure is the absence of keys in the `secrets.json`
file. For example, if you've added new `keys` there during development of a new feature
and haven't updated the keys in the `server` then the application would not be
able to find the `keys` and exit with an error. 

The best way to handle this is by adding the new `keys` and the corresponding values
in the `server` before raising the PR. However, if you have forgotten to add those and
successfully identified that the missing keys are the root of the problem, do not freak out!

Add the keys and the values in the `server` first. After adding the keys, re-run
the corresponding `github action` from the `actions` tab in `github`. 

Never forget to ask for help if you are stuck! Happy coding :)



